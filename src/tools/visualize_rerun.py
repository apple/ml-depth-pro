#!/usr/bin/env python3
import argparse
import os
import sys

import cv2
import numpy as np
import rerun as rr
from loguru import logger


def parse_args():
    parser = argparse.ArgumentParser(description="Visualize depth maps using Rerun")
    parser.add_argument(
        "--depth_file",
        type=str,
        required=True,
        help="Path to the depth maps NPZ file generated by run_video_depth_anything",
    )
    parser.add_argument(
        "--image_file",
        type=str,
        required=True,
        help="Path to the original image file for RGB frames",
    )
    parser.add_argument(
        "--output_dir",
        type=str,
        default="./output/visualization",
        help="Output directory for visualization files",
    )
    parser.add_argument(
        "--interactive",
        action="store_true",
        help="Run Rerun in interactive mode instead of recording",
    )

    # Add Rerun-specific arguments
    rr.script_add_args(parser)

    return parser.parse_args()


def visualize_rgb_depth(rgb_image, depth_map, timestamp=None):
    """Visualize RGB and depth images with 3D visualization using Rerun's Pinhole camera model.

    Args:
    ----
        rgb_image: RGB image (H, W, 3)
        depth_map: Depth map (H, W)
        frame_name: Name for this frame in Rerun
        timestamp: Optional timestamp in seconds for timeline visualization

    """
    # Set the timeline timestamp if provided
    if timestamp is not None:
        rr.set_time_seconds("frame_time", timestamp)

    # Define the camera parameters using Pinhole model
    h, w = depth_map.shape
    rr.log(
        "world/camera/image",
        rr.Pinhole(
            resolution=[w, h],
            focal_length=0.7 * w,  # Using the same focal length as the official example
        ),
    )

    # Log RGB image with compression
    rr.log("world/camera/image/rgb", rr.Image(rgb_image).compress(jpeg_quality=95))

    # Log depth image
    # Note: You might need to adjust DEPTH_IMAGE_SCALING based on your depth units
    DEPTH_IMAGE_SCALING = 1.0  # Adjust if your depth is not in meters
    rr.log("world/camera/image/depth", rr.DepthImage(depth_map, meter=DEPTH_IMAGE_SCALING))

    # Reset timeline
    rr.reset_time()


def main():
    args = parse_args()

    # Configure logger
    logger.remove()
    logger.add(sys.stderr, level="INFO")
    logger.add(f"{args.output_dir}/log.txt", level="DEBUG", rotation="10 MB")

    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)

    # Load depth maps
    logger.info(f"Loading depth maps from {args.depth_file}")
    with np.load(args.depth_file) as data:
        depth_map = data["depth"]
    logger.info(f"Loaded {len(depth_map)} depth map")

    # Load RGB image
    rgb_image = cv2.imread(args.image_file)

    # Initialize Rerun
    recording_id = os.path.basename(args.depth_file).split(".")[0]
    rr.init(recording_id, spawn=args.interactive)

    # Use the simplified visualization without 3D point cloud
    visualize_rgb_depth(
        rgb_image=rgb_image,
        depth_map=depth_map,
        timestamp=0,
    )

    # If not in interactive mode, save the recording
    if not args.interactive:
        logger.info(f"Saving Rerun recording to {args.output_dir}/rerun_recording.rrd")
        rr.save(f"{args.output_dir}/rerun_recording.rrd")
        logger.info("Visualization complete")
    else:
        logger.info("Interactive visualization running. Press Ctrl+C to exit.")
        # Keep the program running for interactive visualization
        try:
            import time

            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("Exiting interactive visualization")

    logger.info(f"All output saved to {args.output_dir}")


if __name__ == "__main__":
    main()
